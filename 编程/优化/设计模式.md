| 设计模式 | 主要使用场景 |
|---|---|---|
| **创建型模式** | 用于创建对象，包括工厂模式、抽象工厂模式、单例模式、建造者模式、原型模式 |
| **结构型模式** | 用于组织对象，包括适配器模式、装饰器模式、外观模式、代理模式、桥接模式、组合模式、享元模式 |
| **行为型模式** | 用于定义对象之间的交互，包括策略模式、模板方法模式、观察者模式、迭代器模式、责任链模式、命令模式、备忘录模式、状态模式、访问者模式 |

**创建型模式**

* **工厂模式**：将对象的创建过程封装起来，让用户无需关心对象的创建细节。
* **抽象工厂模式**：提供一个创建一系列相关或相互依赖对象的接口，而无需指定它们具体的类。
* **单例模式**：保证一个类只有一个实例，并提供一个全局访问点。
* **建造者模式**：将复杂对象的构建过程分解为多个步骤，由不同的对象来完成。
* **原型模式**：通过拷贝已有对象来创建新对象，避免了直接创建对象的复杂性。

**结构型模式**

* **适配器模式**：将一个类的接口转换成客户希望的另一个接口。
* **装饰器模式**：动态地给对象添加新的功能，而无需修改对象的代码。
* **外观模式**：为复杂的子系统提供一个简单的接口。
* **代理模式**：为另一个对象提供一个替代，以控制对该对象的访问。
* **桥接模式**：将抽象部分与实现部分分离，使它们可以独立地变化。
* **组合模式**：将对象组合成树形结构，以表示“整体-部分”的关系。
* **享元模式**：在需要大量对象的情况下，通过共享对象来节省内存。

**行为型模式**

* **策略模式**：定义一系列算法，并将它们封装起来，使它们可以相互替换。
* **模板方法模式**：定义一个操作的框架，而将一些步骤延迟到子类中实现。
* **观察者模式**：当对象发生状态变化时，通知其他对象。
* **迭代器模式**：提供一种遍历容器对象的方法，而无需暴露容器的内部结构。
* **责任链模式**：将请求沿着链式结构传递，直到被某个对象处理。
* **命令模式**：将请求封装成对象，以便使用不同的请求对客户端和接收者进行解耦。
* **备忘录模式**：在不破坏封装性的前提下，捕获对象的内部状态，并在需要时恢复对象的状态。
* **状态模式**：允许对象在其内部状态改变时，改变其行为。
* **访问者模式**：在不修改对象本身的情况下，为对象添加新的功能。

**使用场景**

设计模式的使用场景取决于具体的需求。一般来说，可以根据以下几个方面来考虑：

* **对象的创建方式**：如果对象的创建过程比较复杂，可以使用工厂模式或抽象工厂模式来简化创建过程。如果需要保证一个类只有一个实例，可以使用单例模式。如果需要动态地给对象添加新的功能，可以使用装饰器模式。
* **对象之间的关系**：如果对象之间存在“整体-部分”的关系，可以使用组合模式。如果对象之间存在“依赖”关系，可以使用适配器模式或装饰器模式。
* **对象的行为**：如果需要在对象之间传递请求，可以使用命令模式或观察者模式。如果需要在对象的状态发生变化时通知其他对象，可以使用观察者模式或状态模式。

在实际开发中，可以根据具体需求灵活地选择合适的设计模式。