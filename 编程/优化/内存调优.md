1. jvm 加载过程
   ```
   加载：通过类的全限定名获取类的二进制字节流，将字节流代表的静态存储结构转化为方法区的运行时数据结构。在内存生成这个类的class对象
   连接：包括三步验证，准备，解析
      验证：保证class文件的字节流中包含的信息符合当前虚拟机的要求，且不危害虚拟机自身安全
      准备：正式为类变量分配内存并设置类变量初始值
      解析：将常量池的符号引用替换为直接引用
   初始化：根据程序员的意愿初始化类变量
   ```
2. java 内存模型
   ```
   本地方法栈
   java虚拟机栈
   java堆
   方法区
   程序计数器
   运行时常量池
   ```
3. 垃圾回收算法
   ```
   1. **标记-清除算法（Mark and Sweep）**：
      - **工作原理**：该算法分为两个阶段，首先标记所有活动对象，然后清除所有未被标记的对象（即垃圾对象）。
      - **缺点**：会产生内存碎片，容易导致频繁的内存碎片整理操作。
   
   2. **复制算法（Copying）**：
      - **工作原理**：将堆内存分为两个区域，每次只使用其中一个区域。在垃圾回收时，将存活的对象从一个区域复制到另一个区域，然后清除原区域中的所有对象。
      - **优点**：解决了标记-清除算法中的内存碎片问题，但是需要额外的空间来进行对象复制。
   
   3. **标记-整理算法（Mark and Compact）**：
      - **工作原理**：先标记活动对象，然后将所有活动对象向内存一端移动，清理掉边界外的垃圾对象，从而整理出连续的内存空间。
      - **优点**：减少了内存碎片，提供了连续的内存空间。
   
   4. **分代垃圾回收算法（Generational Garbage Collection）**：
      - **工作原理**：根据对象的存活周期将堆分为不同的代（Generation）。通常将新创建的对象放入新生代，较长时间存活的对象放入老年代。
      - **优点**：针对不同代使用不同的垃圾回收算法，比如新生代一般使用复制算法，老年代使用标记-整理算法，以优化垃圾回收效率。
   ```
4. 什么情况下对象进入老年代
   ```
   大对象直接进入老年代（需要大量连续空间的对象）。常见的大对象就是很长的字符串和数组
   长期存活的对象进入老年代。每个对象有一个年龄计数器。每熬过一次moinor gc，年龄就增加一岁。当年龄增加到一定程度（默认为15）就会晋升到老年代（通过MaxTenuringThreshold设置）。
   动态年龄判断：如果survivor空间某个年龄对象的大小大于survivor空间的一半，年龄大于或等于的直接进入老年代
   空间分配担保：复制算法中，survivor中无法容纳的对象将通过分配担保机制直接进入老年代
   ```
5. 引用
   1. 强引用
   2. 软引用 SoftReference 没空间就回收
   3. 弱引用 WeakReference 回收就没了
   4. 虚引用 PhantomReference 获取不到
       堆外内存管理，直接内存管理，zeroCopy，DirectByteBuffer
6. Tomcat内存调优
   ```
   -Xmx3550m：设置JVM最大可用内存为3550M。 
   -Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 
   -Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 
   -Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 
   -XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5 
   -XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6 
   -XX:MaxPermSize=16m:设置持久代大小为16m。 
   -XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比
    
   java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100 
    
   -XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。 
   -XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。 
   -XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集 
   -XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。 
   -XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。 
   并发收集器（响应时间优先） 
   示例：java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC 
   -XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。 
   -XX:+UseParNewGC: 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。 
   -XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。 
   -XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片 
   ```