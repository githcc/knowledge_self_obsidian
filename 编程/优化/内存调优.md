1. jvm 加载过程
   ```
   加载：通过类的全限定名获取类的二进制字节流，将字节流代表的静态存储结构转化为方法区的运行时数据结构。在内存生成这个类的class对象
   连接：包括三步验证，准备，解析
   验证：保证class文件的字节流中包含的信息符合当前虚拟机的要求，且不危害虚拟机自身安全
   准备：正式为类变量分配内存并设置类变量初始值
   解析：将常量池的符号引用替换为直接引用
   初始化：根据程序员的意愿初始化类变量
   ```
2. java 内存模型
   ```
   程序计数器
   java虚拟机栈
   本地方法栈
   java堆
   方法区
   运行时常量池
   直接内存
   ```
3. 垃圾回收算法
   ```
   标记-清除算法：首先标记出所有的对象，标记完成后统一回收
   （1效率问题：标记和清除两个过程效率都不高
   （2空间问题：产生碎片
   复制算法：将内存划分为一块较大的Eden空间（80%）和两块较小的Survivor空间（10%），每次使用Eden和其中的一块Survivor，当回收时，将两者中存活的对象一次性复制到另一块Survivor，并清空刚才用到的空间，如果这块Survivor不够，则启用分配担保机制，将多处的对象存储再老年代
   标记-整理算法：首先标记出所有的对象，回收时让存活的对象都向一端移动，直接清理端边界外的内存
   分代收集算法：将java堆分为新生代和老年代，垃圾回收时，新生代每次都有大量对象死去，所以采用复制算法，老年代存活的对象较多，使用标记-清除或标记-整理
   ```
4. 什么情况下对象进入老年代
   ```
   大对象直接进入老年代（需要大量连续空间的对象）。常见的大对象就是很长的字符串和数组
   长期存活的对象进入老年代。每个对象有一个年龄计数器。每熬过一次moinor gc，年龄就增加一岁。当年龄增加到一定程度（默认为15）就会晋升到老年代（通过MaxTenuringThreshold设置）。
   动态年龄判断：如果survivor空间某个年龄对象的大小大于survivor空间的一半，年龄大于或等于的直接进入老年代
   空间分配担保：复制算法中，survivor中无法容纳的对象将通过分配担保机制直接进入老年代
   ```
5. Tomcat内存调优
   ```
   -Xmx3550m：设置JVM最大可用内存为3550M。 
   -Xms3550m：设置JVM促使内存为3550m。此值可以设置与-Xmx相同，以避免每次垃圾回收完成后JVM重新分配内存。 
   -Xmn2g：设置年轻代大小为2G。整个堆大小=年轻代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m，所以增大年轻代后，将会减小年老代大小。此值对系统性能影响较大，Sun官方推荐配置为整个堆的3/8。 
   -Xss128k：设置每个线程的堆栈大小。JDK5.0以后每个线程堆栈大小为1M，以前每个线程堆栈大小为256K。更具应用的线程所需内存大小进行调整。在相同物理内存下，减小这个值能生成更多的线程。但是操作系统对一个进程内的线程数还是有限制的，不能无限生成，经验值在3000~5000左右。 
   -XX:NewRatio=4:设置年轻代（包括Eden和两个Survivor区）与年老代的比值（除去持久代）。设置为4，则年轻代与年老代所占比值为1：4，年轻代占整个堆栈的1/5 
   -XX:SurvivorRatio=4：设置年轻代中Eden区与Survivor区的大小比值。设置为4，则两个Survivor区与一个Eden区的比值为2:4，一个Survivor区占整个年轻代的1/6 
   -XX:MaxPermSize=16m:设置持久代大小为16m。 
   -XX:MaxTenuringThreshold=0：设置垃圾最大年龄。如果设置为0的话，则年轻代对象不经过Survivor区，直接进入年老代。对于年老代比
    
   java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseParallelGC  -XX:MaxGCPauseMillis=100 
    
   -XX:+UseParallelGC：选择垃圾收集器为并行收集器。此配置仅对年轻代有效。即上述配置下，年轻代使用并发收集，而年老代仍旧使用串行收集。 
   -XX:ParallelGCThreads=20：配置并行收集器的线程数，即：同时多少个线程一起进行垃圾回收。此值最好配置与处理器数目相等。 
   -XX:+UseParallelOldGC：配置年老代垃圾收集方式为并行收集。JDK6.0支持对年老代并行收集 
   -XX:MaxGCPauseMillis=100:设置每次年轻代垃圾回收的最长时间，如果无法满足此时间，JVM会自动调整年轻代大小，以满足此值。 
   -XX:+UseAdaptiveSizePolicy：设置此选项后，并行收集器会自动选择年轻代区大小和相应的Survivor区比例，以达到目标系统规定的最低相应时间或者收集频率等，此值建议使用并行收集器时，一直打开。 
   并发收集器（响应时间优先） 
   示例：java -Xmx3550m -Xms3550m -Xmn2g -Xss128k -XX:+UseConcMarkSweepGC 
   -XX:+UseConcMarkSweepGC：设置年老代为并发收集。测试中配置这个以后，-XX:NewRatio=4的配置失效了，原因不明。所以，此时年轻代大小最好用-Xmn设置。 
   -XX:+UseParNewGC: 设置年轻代为并行收集。可与CMS收集同时使用。JDK5.0以上，JVM会根据系统配置自行设置，所以无需再设置此值。 
   -XX:CMSFullGCsBeforeCompaction：由于并发收集器不对内存空间进行压缩、整理，所以运行一段时间以后会产生“碎片”，使得运行效率降低。此值设置运行多少次GC以后对内存空间进行压缩、整理。 
   -XX:+UseCMSCompactAtFullCollection：打开对年老代的压缩。可能会影响性能，但是可以消除碎片 
   ```