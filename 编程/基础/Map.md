## hashmap底层原理
1. 底层维护了一个数组
2. 存放的内容可能是值，链表，红黑树
3. 存入时会先进行计算hash值
4. 当链表长度大于8时会有链表转红黑树（jdk8）
5. 使用尾插法（jdk8）
6. 负载因子默认是0.75，可以设置0-1，低为效率优先，高为空间优先
   1. 负载因子=存入的数据/总大小，是否发生hash冲突的情况都是一样
7. 扩容为原来的两倍
    ```
    // 创建一个负载因子为 0.5 的 HashMap
    HashMap<Integer, String> map = new HashMap<>(16, 0.5f);
    ```

## 头插法与尾插法
头插法 （先讲原位置的数据移到后1位，再插入数据到该位置）
尾插法 （直接插入到链表尾部/红黑树）

## 红黑树
1. 黑色不存数据
2. 相邻节点不能为红色
3. 任意节点到可到达的叶节点包含相同数量黑色节点
4. 查找，修改，删除的性能都比较稳定

## hashSet底层原理
HashSet 是基于 HashMap 实现的，HashSet的值存放于HashMap的key上，HashMap的value统一为PRESENT

## HashMap的扩容操作是怎么实现
1. 新建新的hash表，大小是原来两倍
2. 重新计算hash值然后进行移动
3. 红黑树或链表拆分为2个，红黑树的大小小于8会退化成链表
4. jdk1.7在多线程的情况下可能会出现循环链表问题

## hashmap的hash计算
相比在1.7中的4次位运算，5次异或运算（9次扰动）
在1.8中，只进行 了1次位运算和1次异或运算（2次扰动）

## HashTable和ConcurrentHashMap的区别
1. ConcurrentHashMap的锁粒度比较细，使用分段锁