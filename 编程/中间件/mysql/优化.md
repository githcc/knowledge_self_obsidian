
## 优化
1. 减少使用*，减少优化器负担，*会进行替换
2. 只用自己需要的字段，优化网络io
3. 偏移量可以转化为where，减少范围
4. exists/in 的合理使用，小表驱动大表
5. 进行批量插入
6. 在控制台输入sql的时候，语句较为庞大，可以手动开启事务

## 其它
1. mysql不使用二叉树的原因是可能会变成链表
2. 红黑树又名平衡二叉树
3. myisam 
   1. frm 表结构 myd 数据 myi 索引
4. innodb
   1. frm 表结构 ibd 数据与索引
5. 聚集索引 数据与索引放一起，否则反之
6. hash不支持范围查找
7. innoDB推荐使用整型自增主键，雪花算法（递增）
8. explain执行计划
   1. select_type： 这表示查询的类型，可能是 SIMPLE（简单查询）、PRIMARY（主查询中的第一个查询）、SUBQUERY（子查询中的第一个查询）、DERIVED（派生表，例如在 FROM 子句中的子查询）、UNION（UNION 中的第一个查询）等。不同类型可能对性能产生不同影响。
   2. table： 此列显示了查询涉及的表名。 
   3. type： 这表示连接类型，表示了 MySQL 选择了怎样的方式来连接表，常见的取值有 ALL、index、range、ref 等，它们代表了从最坏到最好的连接类型。一般来说，应尽量避免 ALL，因为它表示全表扫描，而更倾向于使用更有效的索引扫描。 
   4. possible_keys： 显示可能应用在这张表中的索引。如果查询涉及多个表，可能出现多个索引，这列可能会显示多个索引，以逗号分隔。 
   5. key： 实际使用的索引，如果没有使用索引，将显示为 NULL。 
   6. key_len： 表示索引中使用的字节数。这可以帮助你了解 MySQL 在查询时使用了多少字节的索引。一般来说，这个值越小越好，因为它减少了 MySQL 所需的内存和磁盘消耗。 
   7. ref： 显示索引的哪一列被使用了，如果可能的话。如果索引是唯一的，这列将显示 const。 
   8. rows： 这是对查询优化的估计，表示 MySQL 预计必须检查的行数。这个值越小越好，因为它表示 MySQL 需要扫描的行数越少。
9. join原理
   1. **Nested Loop Join（嵌套循环连接）：**
      - 这是最简单的 JOIN 算法之一。
      - 它通过对一个表的每一行进行循环，然后对另一个表进行匹配，找到符合连接条件的行。
      - 这种方法适用于一个表的行数相对较少，另一个表的索引被充分利用的情况。
   2. **Hash Join（哈希连接）：**
      - 这种连接算法涉及将连接列的值哈希化，然后在内存中构建哈希表。
      - 对于两个表，连接列的值被哈希化并存储在哈希表中，然后匹配哈希值相同的条目。
      - 这种方法适用于内存足够大的情况下，可以快速构建哈希表，并且适合在大型数据集上执行连接操作。
   3. **Merge Join（合并连接）：**
      - 这种方法适用于两个表都按连接列有序排列的情况。
      - 它通过对两个已经排序的表进行同时扫描，将符合连接条件的行合并在一起。
      - 这种方法对于有序数据集合和大型数据集的连接操作效率较高。



## 参考资料
1. bilibili:[SQL调优](https://www.bilibili.com/video/BV1ko4y1N7x6?p=2)
2. openai：[chatgpt](https://chat.openai.com/)